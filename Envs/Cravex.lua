local TeleportService = game:GetService("TeleportService")local StarterGui = game:GetService("StarterGui")local Players = game:GetService("Players")local RunService = game:GetService("RunService")local UserInputService = game:GetService("UserInputService")local discordLink = "https://dsc.gg/getcravex" -- shit sploit paste btwlocal timeout = 20 while ContentProvider.RequestQueueSize > 0 do    if (tick() - startTime) > timeout then        warn("ContentProvider queue took too long, forcing continuation...")        break    end    task.wait(0.1)endlocal queueSize = ContentProvider.RequestQueueSizewarn(queueSize)queueSize = nilpcall(function()    StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true)end)local EXECUTOR_INFO = {    execname = "Cravex",    execver = "0.1.5"}local luarmourEnabled = falselocal WATERMARK_CONFIG = {    name = "Cravex",    showTime = true,    show24Time = false,    antiDelete = true }local LoadingUI = {}local function CreateLoadingUI()    local gui = Instance.new("ScreenGui")    gui.Name = "CravexLoading"    gui.ResetOnSpawn = false    gui.DisplayOrder = 9999    gui.IgnoreGuiInset = true            if game:GetService("CoreGui") then        gui.Parent = game:GetService("CoreGui")    else        gui.Parent = game:GetService("StarterGui")    end    local mainFrame = Instance.new("Frame")    mainFrame.Name = "MainFrame"    mainFrame.Size = UDim2.new(0, 400, 0, 120)    mainFrame.Position = UDim2.new(0.5, -200, 0.5, -60)    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)    mainFrame.BorderSizePixel = 0    mainFrame.Parent = gui        local uiCorner = Instance.new("UICorner")    uiCorner.CornerRadius = UDim.new(0, 8)    uiCorner.Parent = mainFrame        local uiStroke = Instance.new("UIStroke")    uiStroke.Color = Color3.fromRGB(60, 60, 60)    uiStroke.Thickness = 1    uiStroke.Parent = mainFrame    local title = Instance.new("TextLabel")    title.Name = "Title"    title.Size = UDim2.new(1, 0, 0, 40)    title.BackgroundTransparency = 1    title.Text = "Module Executor"    title.TextColor3 = Color3.fromRGB(255, 255, 255)    title.TextSize = 20    title.Font = Enum.Font.GothamBold    title.Parent = mainFrame        local status = Instance.new("TextLabel")    status.Name = "Status"    status.Size = UDim2.new(1, 0, 0, 30)    status.Position = UDim2.new(0, 0, 0, 40)    status.BackgroundTransparency = 1    status.Text = "Initializing..."    status.TextColor3 = Color3.fromRGB(180, 180, 180)    status.TextSize = 14    status.Font = Enum.Font.Gotham    status.Parent = mainFrame    local barBg = Instance.new("Frame")    barBg.Name = "BarBackground"    barBg.Size = UDim2.new(0.8, 0, 0, 6)    barBg.Position = UDim2.new(0.1, 0, 0.75, 0)    barBg.BackgroundColor3 = Color3.fromRGB(40, 40, 40)    barBg.BorderSizePixel = 0    barBg.Parent = mainFrame        local barCorner = Instance.new("UICorner")    barCorner.CornerRadius = UDim.new(1, 0)    barCorner.Parent = barBg        local barFill = Instance.new("Frame")    barFill.Name = "BarFill"    barFill.Size = UDim2.new(0, 0, 1, 0)    barFill.BackgroundColor3 = Color3.fromRGB(138, 43, 226)     barFill.BorderSizePixel = 0    barFill.Parent = barBg        local fillCorner = Instance.new("UICorner")    fillCorner.CornerRadius = UDim.new(1, 0)    fillCorner.Parent = barFill	gui.Enabled = false	mainFrame.Visible = false    function LoadingUI:Update(percent, text)        status.Text = text or status.Text        barFill:TweenSize(UDim2.new(percent/100, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.3, true)    end    function LoadingUI:Destroy()        gui:Destroy()    end    return LoadingUIendlocal function CreateWatermark()    local TweenService = game:GetService("TweenService")        local gui = Instance.new("ScreenGui")    gui.Name = "CravexWatermark"    gui.ResetOnSpawn = false    gui.DisplayOrder = 99999    gui.IgnoreGuiInset = true        if game:GetService("CoreGui") then        gui.Parent = game:GetService("CoreGui")    else        gui.Parent = game:GetService("StarterGui")    end    local container = Instance.new("Frame")    container.Name = "WatermarkContainer"    container.Size = UDim2.new(0, 220, 0, 32)    container.Position = UDim2.new(1, -235, 1, -50) -- Bottom-right corner    container.BackgroundColor3 = Color3.fromRGB(20, 18, 28)    container.BackgroundTransparency = 0.25    container.BorderSizePixel = 0    container.Parent = gui    local containerCorner = Instance.new("UICorner")    containerCorner.CornerRadius = UDim.new(0, 6)    containerCorner.Parent = container    local containerStroke = Instance.new("UIStroke")    containerStroke.Color = Color3.fromRGB(60, 50, 80)    containerStroke.Thickness = 1    containerStroke.Transparency = 0.5    containerStroke.Parent = container    local accentBar = Instance.new("Frame")    accentBar.Name = "AccentBar"    accentBar.Size = UDim2.new(0, 4, 1, -8)    accentBar.Position = UDim2.new(0, 6, 0, 4)    accentBar.BackgroundColor3 = Color3.fromRGB(138, 43, 226)    accentBar.BorderSizePixel = 0    accentBar.Parent = container    local accentCorner = Instance.new("UICorner")    accentCorner.CornerRadius = UDim.new(1, 0)    accentCorner.Parent = accentBar    local accentGradient = Instance.new("UIGradient")    accentGradient.Color = ColorSequence.new({        ColorSequenceKeypoint.new(0, Color3.fromRGB(180, 80, 255)),        ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 20, 180))    })    accentGradient.Rotation = 90    accentGradient.Parent = accentBar    local label = Instance.new("TextLabel")    label.Name = "WatermarkLabel"    label.Size = UDim2.new(1, -22, 1, 0)    label.Position = UDim2.new(0, 18, 0, 0)    label.BackgroundTransparency = 1    label.TextColor3 = Color3.fromRGB(240, 240, 245)    label.TextSize = 14    label.Font = Enum.Font.GothamMedium -- reverted back    label.TextXAlignment = Enum.TextXAlignment.Left    label.Parent = container    local shadow = Instance.new("ImageLabel")    shadow.Name = "Shadow"    shadow.Size = UDim2.new(1, 20, 1, 20)    shadow.Position = UDim2.new(0, -10, 0, -10)    shadow.BackgroundTransparency = 1    shadow.Image = "rbxassetid://6015897843"    shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)    shadow.ImageTransparency = 0.6    shadow.ScaleType = Enum.ScaleType.Slice    shadow.SliceCenter = Rect.new(49, 49, 450, 450)    shadow.ZIndex = -1    shadow.Parent = container    container.BackgroundTransparency = 1    containerStroke.Transparency = 1    accentBar.BackgroundTransparency = 1    label.TextTransparency = 1    shadow.ImageTransparency = 1    -- Tween appearance    task.spawn(function()        task.wait(0.5)        TweenService:Create(container, TweenInfo.new(0.4, Enum.EasingStyle.Quad), { BackgroundTransparency = 0.25 }):Play()        TweenService:Create(containerStroke, TweenInfo.new(0.4), { Transparency = 0.5 }):Play()        TweenService:Create(accentBar, TweenInfo.new(0.4), { BackgroundTransparency = 0 }):Play()        TweenService:Create(label, TweenInfo.new(0.4), { TextTransparency = 0 }):Play()        TweenService:Create(shadow, TweenInfo.new(0.4), { ImageTransparency = 0.6 }):Play()    end)    -- Draggable    local dragging, dragInput, dragStart, startPos    local function update(input)        local delta = input.Position - dragStart        container.Position = UDim2.new(            startPos.X.Scale, startPos.X.Offset + delta.X,            startPos.Y.Scale, startPos.Y.Offset + delta.Y        )    end    container.InputBegan:Connect(function(input)        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then            dragging = true            dragStart = input.Position            startPos = container.Position            input.Changed:Connect(function()                if input.UserInputState == Enum.UserInputState.End then                    dragging = false                end            end)        end    end)    container.InputChanged:Connect(function(input)        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then            dragInput = input        end    end)    game:GetService("UserInputService").InputChanged:Connect(function(input)        if input == dragInput and dragging then            update(input)        end    end)    -- Keep existing functions intact    local function updateText()        local text = WATERMARK_CONFIG.name        if WATERMARK_CONFIG.showTime then            local timeFormat = WATERMARK_CONFIG.show24Time and "%H:%M:%S" or "%I:%M:%S %p"            text = text .. " | " .. os.date(timeFormat)        end        label.Text = text                local textBounds = game:GetService("TextService"):GetTextSize(text, 14, Enum.Font.GothamMedium, Vector2.new(500, 32))        container.Size = UDim2.new(0, math.max(textBounds.X + 30, 150), 0, 32)    end    updateText()        task.spawn(function()        while gui.Parent do            if WATERMARK_CONFIG.showTime then                updateText()            end                        local randomName = ""            for i = 1, math.random(10, 20) do                randomName = randomName .. string.char(math.random(97, 122))            end            gui.Name = randomName                        task.wait(0.5)        end    end)    if WATERMARK_CONFIG.antiDelete then        gui.AncestryChanged:Connect(function(_, parent)            if not parent then                CravexEnvironemnt.messagebox("You tried deleting the watermark!", "Warning", 0)                CravexEnvironemnt.closeroblox()                while true do end            end        end)    endendlocal loader = CreateLoadingUI()while not game:IsLoaded() do    task.wait()end--CreateWatermark()local cg = game:GetService("CoreGui")local hs = game:GetService("HttpService")local is = game:GetService("InsertService")local ps = game:GetService("Players")local ExternalExecutor = Instance.new("Folder", cg)ExternalExecutor.Name = "ExternalExecutor"local Pointer = Instance.new("Folder", ExternalExecutor)Pointer.Name = "Pointer"local Bridge = Instance.new("Folder", ExternalExecutor)Bridge.Name = "Bridge"local plr = ps.LocalPlayerlocal rtypeof = typeoflocal rs = cg:FindFirstChild("RobloxGui")local ms = rs:FindFirstChild("Modules")local cm = ms:FindFirstChild("Common")local Load = cm:FindFirstChild("CommonUtil")local BridgeUrl = "http://localhost:9611"local ProcessID = "%-PROCESS-ID-%"local Vernushwd = "CravexExecutor-HWID-" .. plr.UserIdlocal resc = 3local function nukedata(dta, typ, set)	local timeout = 5	local result, clock = nil, tick()	dta = dta or ""	typ = typ or "none"	set = set or {}	hs:RequestInternal({		Url = BridgeUrl .. "/handle",		Body = typ .. "\n" .. ProcessID .. "\n" .. hs:JSONEncode(set) .. "\n" .. dta,		Method = "POST",		Headers = {			['Content-Type'] = "text/plain",		}	}):Start(function(success, body)		result = body		result['Success'] = success	end)	while not result do task.wait()		if (tick() - clock > timeout) then			break		end	end	if not result or not result.Success then		if resc <= 0 then			warn("API: Save failed")			return {}		else			resc -= 1		end	else		resc = 3	end		return result and result.Body or ""endlocal CravexEnvironemnt = getfenv(function() end)CravexEnvironemnt.getgenv = function()	return CravexEnvironemntendCravexEnvironemnt.debug = table.clone(debug)CravexEnvironemnt.debug.getinfo = function(f, options)    if type(options) == "string" then        options = string.lower(options)    else        options = "sflnua"    end    local result = {}    for index = 1, #options do        local option = string.sub(options, index, index)        if "s" == option then            local short_src = debug.info(f, "s")            result.short_src = short_src            result.source = "=" .. short_src			if short_src == "[C]" then                result.what = "C"            else                result.what = "Lua"            end        elseif "f" == option then            result.func = debug.info(f, "f")        elseif "l" == option then            result.currentline = debug.info(f, "l")        elseif "n" == option then            result.name = debug.info(f, "n")        elseif "u" == option or option == "a" then            local numparams, is_vararg = debug.info(f, "a")            result.numparams = numparams            result.is_vararg = if is_vararg then 1 else 0            if "u" == option then                result.nups = 0            end        end    end    return resultendCravexEnvironemnt.debug.getstack = function(level, index)    return nilendCravexEnvironemnt.debug.setstack = function(level, index, value)    return falseendCravexEnvironemnt.debug.getconstants = function(f)	if type(f) ~= "function" then		error("invalid argument #1 to 'getconstants' (function expected)", 2)	end	return {}endCravexEnvironemnt.debug.getconstant = function(f, index)	if type(f) ~= "function" then		error("invalid argument #1 to 'getconstant' (function expected)", 2)	end	return nilendCravexEnvironemnt.debug.setconstant = function(f, index, value)	if type(f) ~= "function" then		error("invalid argument #1 to 'setconstant' (function expected)", 2)	end	return trueendCravexEnvironemnt.debug.getupvalue = function(func, index)    assert(type(func) == "function", "expected function")    assert(type(index) == "number", "expected number")    return debug.getupvalue(func, index)endCravexEnvironemnt.debug.getupvalues = function(func)    assert(type(func) == "function", "expected function")    local result = {}    local i = 1    while true do        local name, value = debug.getupvalue(func, i)        if not name then break end        table.insert(result, {name = name, value = value})        i = i + 1    end    return resultendCravexEnvironemnt.debug.setupvalue = function(func, index, value)    assert(type(func) == "function", "expected function")    assert(type(index) == "number", "expected number")    return debug.setupvalue(func, index, value)endCravexEnvironemnt.debug.getprotos = function(f)	if type(f) ~= "function" then		error("invalid argument #1 to 'getprotos' (function expected)", 2)	end	return {}endCravexEnvironemnt.debug.getproto = function(f, index, activated)	if type(f) ~= "function" then		error("invalid argument #1 to 'getproto' (function expected)", 2)	end	if activated then		return {}	end	return function() endendCravexEnvironemnt.debug.testprint = function()print("Debug Table works bitch")endCravexEnvironemnt.identifyexecutor = function()	if luarmourEnabled then		return "Seliware", "1.0"	end	return EXECUTOR_INFO.execname, EXECUTOR_INFO.execverendCravexEnvironemnt.getexecutorname = function()	if luarmourEnabled then		return "Seliware"	end	return EXECUTOR_INFO.execnameendCravexEnvironemnt.getexecutorversion = function()	if luarmourEnabled then		return "1.0"	end	return EXECUTOR_INFO.execverend--[[CravexEnvironemnt.supportluarmour = function(enabled)	assert(type(enabled) == "boolean", "invalid argument #1 to 'supportluarmour' (boolean expected, got " .. type(enabled) .. ") ", 2)	luarmourEnabled = enabledend]]--CravexEnvironemnt.compile = function(code : string, encoded : bool)	local code = typeof(code) == "string" and code or ""	local encoded = typeof(encoded) == "boolean" and encoded or false	local res = nukedata(code, "compile", {		["enc"] = tostring(encoded)	})	return res or ""endCravexEnvironemnt.setscriptbytecode = function(script : Instance, bytecode : string)	local obj = Instance.new("ObjectValue", Pointer)	obj.Name = hs:GenerateGUID(false)	obj.Value = script	nukedata(bytecode, "setscriptbytecode", {		["cn"] = obj.Name	})	obj:Destroy()endlocal clonerefs = {}CravexEnvironemnt.cloneref = function(obj)	local proxy = newproxy(true)	local meta = getmetatable(proxy)	meta.__index = function(t, n)		local v = obj[n]		if typeof(v) == "function" then			return function(self, ...)				if self == t then					self = obj				end				return v(self, ...)			end		else			return v		end	end	meta.__newindex = function(t, n, v)		obj[n] = v	end	meta.__tostring = function(t)		return tostring(obj)	end	meta.__metatable = getmetatable(obj)	clonerefs[proxy] = obj	return proxyendCravexEnvironemnt.compareinstances = function(proxy1, proxy2)	assert(type(proxy1) == "userdata", "Invalid argument #1 to 'compareinstances' (Instance expected, got " .. typeof(proxy1) .. ")")	assert(type(proxy2) == "userdata", "Invalid argument #2 to 'compareinstances' (Instance expected, got " .. typeof(proxy2) .. ")")	if clonerefs[proxy1] then		proxy1 = clonerefs[proxy1]	end	if clonerefs[proxy2] then		proxy2 = clonerefs[proxy2]	end	return proxy1 == proxy2endlocal rrs = game:GetService("RobloxReplicatedStorage")local AvatarEditorPrompts = ms:FindFirstChild("AvatarEditorPrompts")local function createLoadModule()    if not AvatarEditorPrompts then        return nil    end    local module = AvatarEditorPrompts:Clone()    module.Archivable = false    module.Name = "Exec_" .. hs:GenerateGUID(false)    module.Parent = rrs    return moduleendCravexEnvironemnt.loadstring = function(code, chunkname)	assert(type(code) == "string", "invalid argument #1 to 'loadstring' (string expected, got " .. type(code) .. ") ", 2)	chunkname = chunkname or "loadstring"	assert(type(chunkname) == "string", "invalid argument #2 to 'loadstring' (string expected, got " .. type(chunkname) .. ") ", 2)	chunkname = chunkname:gsub("[^%a_]", "")	if (code == "" or code == " ") then		return nil, "Empty script source"	end	local bytecode = CravexEnvironemnt.compile("return{[ [["..chunkname.."]] ]=function(...)local roe=function()return'\67\104\105\109\101\114\97\76\108\101'end;"..code.."\nend}", true)	if #bytecode <= 1 then		return nil, "Compile Failed!"	end    local module = createLoadModule()    if not module then        return nil, "Failed to create execution module"    end	CravexEnvironemnt.setscriptbytecode(module, bytecode)	local suc, res = pcall(function()		return debug.loadmodule(module)	end)    module:Destroy()	if suc then		local suc2, res2 = pcall(function()			return res()		end)		if suc2 and typeof(res2) == "table" and typeof(res2[chunkname]) == "function" then			return setfenv(res2[chunkname], CravexEnvironemnt)		else			return nil, "Failed To Load!"		end	else		return nil, (res or "Failed To Load!")	endendlocal supportedMethods = {"GET", "POST", "PUT", "DELETE", "PATCH"}-- Funzione helper per validare JSONlocal function isValidJson(str)    if type(str) ~= "string" or str:match("^%s*$") then        return false    end        -- Controlli rapidi per JSON    str = str:gsub("^%s+", ""):gsub("%s+$", "") -- Trim        -- JSON deve iniziare con { o [    local firstChar = str:sub(1, 1)    local lastChar = str:sub(-1)        if firstChar ~= "{" and firstChar ~= "[" then        return false    end        -- Deve finire con } o ]    if (firstChar == "{" and lastChar ~= "}") or        (firstChar == "[" and lastChar ~= "]") then        return false    end        -- Validazione completa con pcall    local success, _ = pcall(function()        return hs:JSONDecode(str)    end)        return successend-- Funzione per estrarre solo il Content-Type base (senza charset/boundary)local function getBaseContentType(contentTypeHeader)    if not contentTypeHeader then        return nil    end        -- Estrae solo la parte prima del ; (es: "application/json; charset=utf-8" -> "application/json")    local baseType = contentTypeHeader:match("^([^;]+)")        if baseType then        return baseType:gsub("%s+", "")    end        return contentTypeHeaderend-- Funzione per detectare il Content-Type automaticamentelocal function detectContentType(body, currentHeaders)    -- Se l'utente ha giï¿½ specificato un Content-Type, usiamo quello    if currentHeaders and currentHeaders["Content-Type"] then        return getBaseContentType(currentHeaders["Content-Type"])    end        -- Se non c'ï¿½ body, non serve Content-Type    if not body or body == "" then        return nil    end        -- Detecta in base al contenuto    local trimmedBody = body:gsub("^%s+", ""):gsub("%s+$", "")        -- 1. JSON detection    if isValidJson(body) then        return "application/json"    end        -- 2. XML detection (inizia con <?xml o <tag>)    if trimmedBody:sub(1, 5) == "<?xml" or        (trimmedBody:sub(1, 1) == "<" and trimmedBody:find(">", 1, true)) then        return "application/xml"    end        -- 3. Form URL encoded detection (chiave=valore&chiave2=valore2)    if body:find("=") and body:find("&") and not body:find("[{}%[%]]") then        -- Controlla che non contenga caratteri JSON/XML        if not body:find("[<>]") and not body:match("^%s*[{%[]") then            return "application/x-www-form-urlencoded"        end    end        -- 4. HTML detection (contiene tag HTML comuni)    local htmlTags = {"<html", "<head", "<body", "<div", "<p", "<span", "<a href"}    for _, tag in ipairs(htmlTags) do        if body:lower():find(tag:lower()) then            return "text/html"        end    end        -- 5. Default: text/plain    return "text/plain"endCravexEnvironemnt.request = function(options)    assert(type(options) == "table", "invalid argument #1 to 'request' (table expected, got " .. type(options) .. ") ", 2)	assert(type(options.Url) == "string", "invalid option 'Url' for argument #1 to 'request' (string expected, got " .. type(options.Url) .. ") ", 2)	options.Method = options.Method or "GET"	options.Method = options.Method:upper()	assert(table.find(supportedMethods, options.Method), "invalid option 'Method' for argument #1 to 'request' (a valid http method expected, got '" .. options.Method .. "') ", 2)	assert(not (options.Method == "GET" and options.Body), "invalid option 'Body' for argument #1 to 'request' (current method is GET but option 'Body' was used)", 2)	if options.Body then		assert(type(options.Body) == "string", "invalid option 'Body' for argument #1 to 'request' (string expected, got " .. type(options.Body) .. ") ", 2)		--assert(pcall(function() hs:JSONDecode(options.Body) end), "invalid option 'Body' for argument #1 to 'request' (invalid json string format)", 2)	end	if options.Headers then assert(type(options.Headers) == "table", "invalid option 'Headers' for argument #1 to 'request' (table expected, got " .. type(options.Url) .. ") ", 2) end	options.Body = options.Body or "{}"	options.Headers = options.Headers or {}	if (options.Headers["User-Agent"]) then assert(type(options.Headers["User-Agent"]) == "string", "invalid option 'User-Agent' for argument #1 to 'request.Header' (string expected, got " .. type(options.Url) .. ") ", 2) end	local defaultUserAgent = EXECUTOR_INFO.execname .. "/" .. EXECUTOR_INFO.execver	if luarmourEnabled then		defaultUserAgent = "Seliware/1.0"	end	options.Headers["User-Agent"] = options.Headers["User-Agent"] or defaultUserAgent	options.Headers["CravexFingerprint-Fingerprint"] = Vernushwd	options.Headers["Cache-Control"] = "no-cache"	options.Headers["Roblox-Place-Id"] = tostring(game.PlaceId)	options.Headers["Roblox-Game-Id"] = tostring(game.JobId)	options.Headers["Roblox-Session-Id"] = hs:JSONEncode({		["GameId"] = tostring(game.GameId),		["PlaceId"] = tostring(game.PlaceId)	})	local res = nukedata("", "request", {		['l'] = options.Url,		['m'] = options.Method,		['h'] = options.Headers,		['b'] = options.Body or "{}"	})		if res and res ~= "" then		local success, result = pcall(function() return hs:JSONDecode(res) end)		if success and result then			if result['r'] ~= "OK" then				result['r'] = "Unknown"			end			return {				Success = tonumber(result['c']) and tonumber(result['c']) >= 200 and tonumber(result['c']) < 300,				StatusMessage = result['r'],				StatusCode = tonumber(result['c']),				Body = result['b'],				HttpError = Enum.HttpError[result['r']],				Headers = result['h'],				Version = result['v']			}		end	end		return {		Success = false,		StatusMessage = "Can't connect to Jules web server!",		StatusCode = 599;		HttpError = Enum.HttpError.ConnectFail	}endlocal lookupValueToCharacter = buffer.create(64)local lookupCharacterToValue = buffer.create(256)local alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"local padding = string.byte("=")for index = 1, 64 do	local value = index - 1	local character = string.byte(alphabet, index)	buffer.writeu8(lookupValueToCharacter, value, character)	buffer.writeu8(lookupCharacterToValue, character, value)endlocal function raw_encode(input: buffer): buffer	local inputLength = buffer.len(input)	local inputChunks = math.ceil(inputLength / 3)	local outputLength = inputChunks * 4	local output = buffer.create(outputLength)	for chunkIndex = 1, inputChunks - 1 do		local inputIndex = (chunkIndex - 1) * 3		local outputIndex = (chunkIndex - 1) * 4		local chunk = bit32.byteswap(buffer.readu32(input, inputIndex))		local value1 = bit32.rshift(chunk, 26)		local value2 = bit32.band(bit32.rshift(chunk, 20), 0b111111)		local value3 = bit32.band(bit32.rshift(chunk, 14), 0b111111)		local value4 = bit32.band(bit32.rshift(chunk, 8), 0b111111)		buffer.writeu8(output, outputIndex, buffer.readu8(lookupValueToCharacter, value1))		buffer.writeu8(output, outputIndex + 1, buffer.readu8(lookupValueToCharacter, value2))		buffer.writeu8(output, outputIndex + 2, buffer.readu8(lookupValueToCharacter, value3))		buffer.writeu8(output, outputIndex + 3, buffer.readu8(lookupValueToCharacter, value4))	end	local inputRemainder = inputLength % 3	if inputRemainder == 1 then		local chunk = buffer.readu8(input, inputLength - 1)		local value1 = bit32.rshift(chunk, 2)		local value2 = bit32.band(bit32.lshift(chunk, 4), 0b111111)		buffer.writeu8(output, outputLength - 4, buffer.readu8(lookupValueToCharacter, value1))		buffer.writeu8(output, outputLength - 3, buffer.readu8(lookupValueToCharacter, value2))		buffer.writeu8(output, outputLength - 2, padding)		buffer.writeu8(output, outputLength - 1, padding)	elseif inputRemainder == 2 then		local chunk = bit32.bor(			bit32.lshift(buffer.readu8(input, inputLength - 2), 8),			buffer.readu8(input, inputLength - 1)		)		local value1 = bit32.rshift(chunk, 10)		local value2 = bit32.band(bit32.rshift(chunk, 4), 0b111111)		local value3 = bit32.band(bit32.lshift(chunk, 2), 0b111111)		buffer.writeu8(output, outputLength - 4, buffer.readu8(lookupValueToCharacter, value1))		buffer.writeu8(output, outputLength - 3, buffer.readu8(lookupValueToCharacter, value2))		buffer.writeu8(output, outputLength - 2, buffer.readu8(lookupValueToCharacter, value3))		buffer.writeu8(output, outputLength - 1, padding)	elseif inputRemainder == 0 and inputLength ~= 0 then		local chunk = bit32.bor(			bit32.lshift(buffer.readu8(input, inputLength - 3), 16),			bit32.lshift(buffer.readu8(input, inputLength - 2), 8),			buffer.readu8(input, inputLength - 1)		)		local value1 = bit32.rshift(chunk, 18)		local value2 = bit32.band(bit32.rshift(chunk, 12), 0b111111)		local value3 = bit32.band(bit32.rshift(chunk, 6), 0b111111)		local value4 = bit32.band(chunk, 0b111111)		buffer.writeu8(output, outputLength - 4, buffer.readu8(lookupValueToCharacter, value1))		buffer.writeu8(output, outputLength - 3, buffer.readu8(lookupValueToCharacter, value2))		buffer.writeu8(output, outputLength - 2, buffer.readu8(lookupValueToCharacter, value3))		buffer.writeu8(output, outputLength - 1, buffer.readu8(lookupValueToCharacter, value4))	end	return outputendlocal function raw_decode(input: buffer): buffer	local inputLength = buffer.len(input)	local inputChunks = math.ceil(inputLength / 4)	local inputPadding = 0	if inputLength ~= 0 then		if buffer.readu8(input, inputLength - 1) == padding then inputPadding += 1 end		if buffer.readu8(input, inputLength - 2) == padding then inputPadding += 1 end	end	local outputLength = inputChunks * 3 - inputPadding	local output = buffer.create(outputLength)	for chunkIndex = 1, inputChunks - 1 do		local inputIndex = (chunkIndex - 1) * 4		local outputIndex = (chunkIndex - 1) * 3		local value1 = buffer.readu8(lookupCharacterToValue, buffer.readu8(input, inputIndex))		local value2 = buffer.readu8(lookupCharacterToValue, buffer.readu8(input, inputIndex + 1))		local value3 = buffer.readu8(lookupCharacterToValue, buffer.readu8(input, inputIndex + 2))		local value4 = buffer.readu8(lookupCharacterToValue, buffer.readu8(input, inputIndex + 3))		local chunk = bit32.bor(			bit32.lshift(value1, 18),			bit32.lshift(value2, 12),			bit32.lshift(value3, 6),			value4		)		local character1 = bit32.rshift(chunk, 16)		local character2 = bit32.band(bit32.rshift(chunk, 8), 0b11111111)		local character3 = bit32.band(chunk, 0b11111111)		buffer.writeu8(output, outputIndex, character1)		buffer.writeu8(output, outputIndex + 1, character2)		buffer.writeu8(output, outputIndex + 2, character3)	end	if inputLength ~= 0 then		local lastInputIndex = (inputChunks - 1) * 4		local lastOutputIndex = (inputChunks - 1) * 3		local lastValue1 = buffer.readu8(lookupCharacterToValue, buffer.readu8(input, lastInputIndex))		local lastValue2 = buffer.readu8(lookupCharacterToValue, buffer.readu8(input, lastInputIndex + 1))		local lastValue3 = buffer.readu8(lookupCharacterToValue, buffer.readu8(input, lastInputIndex + 2))		local lastValue4 = buffer.readu8(lookupCharacterToValue, buffer.readu8(input, lastInputIndex + 3))		local lastChunk = bit32.bor(			bit32.lshift(lastValue1, 18),			bit32.lshift(lastValue2, 12),			bit32.lshift(lastValue3, 6),			lastValue4		)		if inputPadding <= 2 then			local lastCharacter1 = bit32.rshift(lastChunk, 16)			buffer.writeu8(output, lastOutputIndex, lastCharacter1)			if inputPadding <= 1 then				local lastCharacter2 = bit32.band(bit32.rshift(lastChunk, 8), 0b11111111)				buffer.writeu8(output, lastOutputIndex + 1, lastCharacter2)				if inputPadding == 0 then					local lastCharacter3 = bit32.band(lastChunk, 0b11111111)					buffer.writeu8(output, lastOutputIndex + 2, lastCharacter3)				end			end		end	end	return outputendCravexEnvironemnt.base64encode = function(input)	return buffer.tostring(raw_encode(buffer.fromstring(input)))endCravexEnvironemnt.base64_encode = CravexEnvironemnt.base64encodeCravexEnvironemnt.base64decode = function(encoded)	return buffer.tostring(raw_decode(buffer.fromstring(encoded)))endCravexEnvironemnt.base64_decode = CravexEnvironemnt.base64decodelocal base64 = {}base64.encode = CravexEnvironemnt.base64encodebase64.decode = CravexEnvironemnt.base64decodeCravexEnvironemnt.base64 = base64CravexEnvironemnt.islclosure = function(func)	assert(type(func) == "function", "invalid argument #1 to 'islclosure' (function expected, got " .. type(func) .. ") ", 2)	return debug.info(func, "s") ~= "[C]"endCravexEnvironemnt.isluaclosure = CravexEnvironemnt.islclosureCravexEnvironemnt.iscclosure = function(func)	assert(type(func) == "function", "invalid argument #1 to 'iscclosure' (function expected, got " .. type(func) .. ") ", 2)	return debug.info(func, "s") == "[C]"endCravexEnvironemnt.newlclosure = function(func)	assert(type(func) == "function", "invalid argument #1 to 'newlclosure' (function expected, got " .. type(func) .. ") ", 2)	local cloned = function(...)		return func(...)	end	return clonedendCravexEnvironemnt.newcclosure = function(func)	assert(type(func) == "function", "invalid argument #1 to 'newcclosure' (function expected, got " .. type(func) .. ") ", 2)	local cloned = coroutine.wrap(function(...)		while true do			coroutine.yield(func(...))		end	end)	return clonedendCravexEnvironemnt.clonefunction = function(func)	assert(type(func) == "function", "invalid argument #1 to 'clonefunction' (function expected, got " .. type(func) .. ") ", 2)	if CravexEnvironemnt.iscclosure(func) then		return CravexEnvironemnt.newcclosure(func)	else		return CravexEnvironemnt.newlclosure(func)	endendlocal user_agent = "ExternalExecutor"function CravexEnvironemnt.HttpGet(url, returnRaw)	assert(type(url) == "string", "invalid argument #1 to 'HttpGet' (string expected, got " .. type(url) .. ") ", 2)	local returnRaw = returnRaw or true	local result = CravexEnvironemnt.request({		Url = url,		Method = "GET",		Headers = {			["User-Agent"] = user_agent		}	})	if returnRaw then		return result.Body	end	return hs:JSONDecode(result.Body)endfunction CravexEnvironemnt.HttpPost(url, body, contentType)	assert(type(url) == "string", "invalid argument #1 to 'HttpPost' (string expected, got " .. type(url) .. ") ", 2)	contentType = contentType or "application/json"	return CravexEnvironemnt.request({		Url = url,		Method = "POST",		body = body,		Headers = {			["Content-Type"] = contentType		}	})endfunction CravexEnvironemnt.GetObjects(asset)	return {		is:LoadLocalAsset(asset)	}endlocal function GenerateError(object)	local _, err = xpcall(function()		object:__namecall()	end, function()		return debug.info(2, "f")	end)	return errendlocal FirstTest = GenerateError(OverlapParams.new())local SecondTest = GenerateError(Color3.new())local cachedmethods = {}CravexEnvironemnt.getnamecallmethod = function()	local _, err = pcall(FirstTest)	local method = if type(err) == "string" then err:match("^(.+) is not a valid member of %w+$") else nil	if not method then		_, err = pcall(SecondTest)		method = if type(err) == "string" then err:match("^(.+) is not a valid member of %w+$") else nil	end	local fixerdata = newproxy(true)	local fixermeta = getmetatable(fixerdata)	fixermeta.__namecall = function()		local _, err = pcall(FirstTest)		local method = if type(err) == "string" then err:match("^(.+) is not a valid member of %w+$") else nil		if not method then			_, err = pcall(SecondTest)			method = if type(err) == "string" then err:match("^(.+) is not a valid member of %w+$") else nil		end	end	fixerdata:__namecall()	if not method or method == "__namecall" then		if cachedmethods[coroutine.running()] then			return cachedmethods[coroutine.running()]		end		return nil	end	cachedmethods[coroutine.running()] = method	return methodendlocal proxyobjectlocal proxied = {}local objects = {}function ToProxy(...)	local packed = table.pack(...)	local function LookTable(t)		for i, obj in ipairs(t) do			if rtypeof(obj) == "Instance" then				if objects[obj] then					t[i] = objects[obj].proxy				else					t[i] = proxyobject(obj)				end			elseif typeof(obj) == "table" then				LookTable(obj)			else				t[i] = obj			end		end	end	LookTable(packed)	return table.unpack(packed, 1, packed.n)endfunction ToObject(...)	local packed = table.pack(...)	local function LookTable(t)		for i, obj in ipairs(t) do			if rtypeof(obj) == "userdata" then				if proxied[obj] then					t[i] = proxied[obj].object				else					t[i] = obj				end			elseif typeof(obj) == "table" then				LookTable(obj)			else				t[i] = obj			end		end	end	LookTable(packed)	return table.unpack(packed, 1, packed.n)endlocal function index(t, n)	local data = proxied[t]	local namecalls = data.namecalls	local obj = data.object	if namecalls[n] then		return function(self, ...)			return ToProxy(namecalls[n](...))		end	end	local v = obj[n]	if typeof(v) == "function" then		return function(self, ...)			return ToProxy(v(ToObject(self, ...)))		end	else		return ToProxy(v)	endendlocal function namecall(t, ...)	local data = proxied[t]	local namecalls = data.namecalls	local obj = data.object	local method = CravexEnvironemnt.getnamecallmethod()	if namecalls[method] then		return ToProxy(namecalls[method](...))	end	return ToProxy(obj[method](ToObject(t, ...)))endlocal function newindex(t, n, v)	local data = proxied[t]	local obj = data.object	local val = table.pack(ToObject(v))	obj[n] = table.unpack(val)endlocal function ptostring(t)	return t.Nameendfunction proxyobject(obj, namecalls)	if objects[obj] then		return objects[obj].proxy	end	namecalls = namecalls or {}	local proxy = newproxy(true)	local meta = getmetatable(proxy)	meta.__index = function(...)return index(...)end	meta.__namecall = function(...)return namecall(...)end	meta.__newindex = function(...)return newindex(...)end	meta.__tostring = function(...)return ptostring(...)end	meta.__metatable = getmetatable(obj)	local data = {}	data.object = obj	data.proxy = proxy	data.meta = meta	data.namecalls = namecalls	proxied[proxy] = data	objects[obj] = data	return proxyendlocal pgame = proxyobject(game, {	HttpGet = CravexEnvironemnt.HttpGet,	HttpGetAsync = CravexEnvironemnt.HttpGet,	HttpPost = CravexEnvironemnt.HttpPost,	HttpPostAsync = CravexEnvironemnt.HttpPost,	GetObjects = CravexEnvironemnt.GetObjects})CravexEnvironemnt.game = pgameCravexEnvironemnt.Game = pgamelocal pworkspace = proxyobject(workspace)CravexEnvironemnt.workspace = pworkspaceCravexEnvironemnt.Workspace = pworkspacelocal pscript = proxyobject(script)CravexEnvironemnt.script = pscriptlocal hui = proxyobject(Instance.new("ScreenGui", cg))hui.Name = "hidden_ui_container"-- Only connect if the LocalPlayer exists, as we determined earlierlocal isPlayerInGame = Players.LocalPlayer or nilif isPlayerInGame then    -- Using the throttling method (easier to implement)    game.DescendantAdded:Connect(function(instance)        task.wait() -- CRITICAL: Throttles the function to prevent stack overflow        if instance and instance.Parent then             proxyobject(instance)        end    end)    warn("DescendantAdded.")endlocal rInstance = Instancelocal fInstance = {}fInstance.new = function(name, par)	return proxyobject(rInstance.new(name, ToObject(par)))endfInstance.fromExisting = function(obj)	return proxyobject(rInstance.fromExisting(obj))endCravexEnvironemnt.Instance = fInstanceCravexEnvironemnt.getinstances = function()	local Instances = {}	for i, v in pairs(objects) do		table.insert(Instances, v.proxy)	end	return InstancesendCravexEnvironemnt.getnilinstances = function()	local NilInstances = {}	for i, v in pairs(objects) do		if v.proxy.Parent == nil then			table.insert(NilInstances, v.proxy)		end	end	return NilInstancesendCravexEnvironemnt.getloadedmodules = function()	local LoadedModules = {}	for i, v in pairs(objects) do		if v.proxy:IsA("ModuleScript") then			table.insert(LoadedModules, v.proxy)		end	end	return LoadedModulesendCravexEnvironemnt.getrunningscripts = function()	local RunningScripts = {}	for i, v in pairs(objects) do		if v.proxy:IsA("ModuleScript") then			table.insert(RunningScripts, v.proxy)		end	end	return RunningScriptsendCravexEnvironemnt.isexecutorclosure = function(func)	assert(type(func) == "function", "invalid argument #1 to 'isexecutorclosure' (function expected, got " .. type(func) .. ") ", 2)	for _, genv in CravexEnvironemnt.getgenv() do		if genv == func then			return true		end	end	local function check(t)		local isglobal = false		for i, v in t do			if type(v) == "table" then				check(v)			end			if v == func then				isglobal = true			end		end		return isglobal	end	if check(CravexEnvironemnt.getgenv().getrenv()) then		return false	end	return trueendCravexEnvironemnt.checkclosure = CravexEnvironemnt.isexecutorclosureCravexEnvironemnt.isourclosure = CravexEnvironemnt.isexecutorclosureCravexEnvironemnt.getscripthash = function(instance) 	assert(typeof(instance) == "Instance", "invalid argument #1 to 'getscripthash' (Instance expected, got " .. typeof(instance) .. ") ", 2)	assert(instance:IsA("LuaSourceContainer"), "invalid argument #1 to 'getscripthash' (LuaSourceContainer expected, got " .. instance.ClassName .. ") ", 2)	local hash = tostring(instance:GetHash())	local hex = ""	for i = 1, #hash do		hex = hex .. string.format("%02x", string.byte(hash, i))	end	return hexendCravexEnvironemnt.getrawmetatable = function(object)    assert(type(object) == "table" or type(object) == "userdata", "invalid argument #1 to 'getrawmetatable' (table or userdata expected, got " .. type(object) .. ")", 2)    local raw_mt = CravexEnvironemnt.debug.getmetatable(object)    if raw_mt and raw_mt.__metatable then        raw_mt.__metatable = nil         local result_mt = CravexEnvironemnt.debug.getmetatable(object)        raw_mt.__metatable = "Locked!"        return result_mt    end    return raw_mtendCravexEnvironemnt.setrawmetatable = function(object, mt)	if type(object) ~= "table" and type(object) ~= "userdata" then		error("invalid argument #1 to 'setrawmetatable' (table or userdata expected)", 2)	end	local raw = debug.getmetatable(object)	if raw and raw.__metatable then		local old = raw.__metatable		raw.__metatable = nil		local s = pcall(setmetatable, object, mt)		raw.__metatable = old		return s	end	return pcall(setmetatable, object, mt)endCravexEnvironemnt.getscripts = function()	local Scripts = {}	for i, v in pairs(objects) do		if v.proxy:IsA("LocalScript") or v.proxy:IsA("ModuleScript") or v.proxy:IsA("Script") then			local parent = v.proxy.Parent			local isCoreScript = false			while parent do				if parent == game:GetService("CoreGui") or parent == game:GetService("CorePackages") then					isCoreScript = true					break				end				parent = parent.Parent			end			if not isCoreScript then				table.insert(Scripts, v.proxy)			end		end	end	return ScriptsendCravexEnvironemnt.getloadedmodules = function()	local modules = {}	for i, v in pairs(objects) do		if v.proxy:IsA("ModuleScript") then			local parent = v.proxy.Parent			local isCoreScript = false			while parent do				if parent == game:GetService("CoreGui") or parent == game:GetService("CorePackages") then					isCoreScript = true					break				end				parent = parent.Parent			end			if not isCoreScript then				table.insert(modules, v.proxy)			end		end	end	return modulesendCravexEnvironemnt.getrunningscripts = function()	local scripts = {}	for i, v in pairs(objects) do		if v.proxy:IsA("LocalScript") or v.proxy:IsA("Script") then			local parent = v.proxy.Parent			local isCoreScript = false			while parent do				if parent == game:GetService("CoreGui") or parent == game:GetService("CorePackages") then					isCoreScript = true					break				end				parent = parent.Parent			end			if not isCoreScript then				table.insert(scripts, v.proxy)			end		end	end	return scriptsendCravexEnvironemnt.checkcaller = function()	return trueendCravexEnvironemnt.filtergc = function(filterType)	filterType = filterType or "function"	local results = {}	local gc_objects = CravexEnvironemnt.getgc(true)	for i, v in pairs(gc_objects) do		if type(v) == filterType then			table.insert(results, v)		end	end	return resultsendCravexEnvironemnt.hookfunction = function(target, hook)	assert(type(target) == "function", "invalid argument #1 to 'hookfunction' (function expected, got " .. type(target) .. ") ", 2)	assert(type(hook) == "function", "invalid argument #2 to 'hookfunction' (function expected, got " .. type(hook) .. ") ", 2)	return falseendCravexEnvironemnt.typeof = function(obj)	local typ = rtypeof(obj)	if typ == "userdata" then		if proxied[obj] then			return "Instance"		else			return typ		end	else		return typ	endendCravexEnvironemnt.gethui = function()	return huiendCravexEnvironemnt.getconnections = function(signal)	if typeof(signal) ~= "RBXScriptSignal" then		return {}	end	return {}endlocal instanceCache = {}CravexEnvironemnt.cache = {}CravexEnvironemnt.cache.invalidate = function(instance)	if typeof(instance) ~= "Instance" then		return	end	instanceCache[instance] = nilendCravexEnvironemnt.cache.iscached = function(instance)	if typeof(instance) ~= "Instance" then		return false	end	return instanceCache[instance] ~= nil or instance.Parent ~= nilendCravexEnvironemnt.cache.replace = function(oldInstance, newInstance)	if typeof(oldInstance) ~= "Instance" or typeof(newInstance) ~= "Instance" then		return	end	instanceCache[oldInstance] = newInstanceendlocal hiddenProps = {}CravexEnvironemnt.gethiddenproperty = function(obj, prop)	if typeof(obj) ~= "Instance" then		error("invalid argument #1 to 'gethiddenproperty' (Instance expected)", 2)	end	if type(prop) ~= "string" then		error("invalid argument #2 to 'gethiddenproperty' (string expected)", 2)	end	if hiddenProps[obj] and hiddenProps[obj][prop] ~= nil then		return hiddenProps[obj][prop], true	end	local s, v = pcall(function()		return obj[prop]	end)	return s and v or nil, falseendCravexEnvironemnt.sethiddenproperty = function(obj, prop, value)	if typeof(obj) ~= "Instance" then		error("invalid argument #1 to 'sethiddenproperty' (Instance expected)", 2)	end	if type(prop) ~= "string" then		error("invalid argument #2 to 'sethiddenproperty' (string expected)", 2)	end	hiddenProps[obj] = hiddenProps[obj] or {}	hiddenProps[obj][prop] = value	pcall(function()		obj[prop] = value	end)	return trueendlocal scriptableProps = {}CravexEnvironemnt.isscriptable = function(obj, prop)	if typeof(obj) ~= "Instance" then		return false	end	if type(prop) ~= "string" then		return false	end	if scriptableProps[obj] and scriptableProps[obj][prop] ~= nil then		return scriptableProps[obj][prop]	end	local s = pcall(function()		return obj[prop]	end)	return sendCravexEnvironemnt.setscriptable = function(obj, prop, value)	if typeof(obj) ~= "Instance" then		return false	end	if type(prop) ~= "string" then		return false	end	local old = CravexEnvironemnt.isscriptable(obj, prop)	scriptableProps[obj] = scriptableProps[obj] or {}	scriptableProps[obj][prop] = value	return oldendCravexEnvironemnt.getscriptbytecode = function(script : Instance)    assert(typeof(script) == "Instance", "invalid argument #1 to 'getscriptbytecode' (Instance expected, got " .. typeof(script) .. ") ", 2)    assert(script:IsA("LuaSourceContainer"), "invalid argument #1 to 'getscriptbytecode' (LuaSourceContainer expected, got " .. script.ClassName .. ") ", 2)        -- Controlla se lo script ha un parent valido (esiste nel gioco)    -- Se ï¿½ un nuovo script creato localmente, ritorna nil    if not script:IsDescendantOf(game) then        return nil    end        -- Verifica se lo script ï¿½ effettivamente caricato/attivo    -- Script nuovi o non eseguiti potrebbero non avere bytecode    local isRunning = false    if script:IsA("Script") or script:IsA("LocalScript") then        isRunning = script.Enabled    end        -- Per ModuleScript, controlla se ï¿½ stato richiesto    if script:IsA("ModuleScript") then        local success = pcall(function()            require(script)        end)        isRunning = success    end        -- Se lo script non ï¿½ in esecuzione/attivo, ritorna nil    if false then --not isRunning then        return nil    end        -- Prova a ottenere il bytecode tramite il sistema C++    local obj = Instance.new("ObjectValue", Pointer)    obj.Name = hs:GenerateGUID(false)    obj.Value = script        local bytecode = nukedata("", "getscriptbytecode", {        ["cn"] = obj.Name    })        obj:Destroy()        -- Se il bytecode ï¿½ vuoto o invalid, ritorna nil    if not bytecode or bytecode == "" or bytecode == "__EE_ERROR__" then        return nil    end        return bytecodeendCravexEnvironemnt.getscriptclosure = function(script)	assert(typeof(script) == "Instance", "invalid argument #1 to 'getscriptclosure' (Instance expected, got " .. typeof(script) .. ") ", 2)	assert(script:IsA("LuaSourceContainer"), "invalid argument #1 to 'getscriptclosure' (LuaSourceContainer expected, got " .. script.ClassName .. ") ", 2)	return function() endendCravexEnvironemnt.getscriptfunction = CravexEnvironemnt.getscriptclosureCravexEnvironemnt.replaceclosure = function(original, replacement)	assert(type(original) == "function", "invalid argument #1 to 'replaceclosure' (function expected, got " .. type(original) .. ") ", 2)	assert(type(replacement) == "function", "invalid argument #2 to 'replaceclosure' (function expected, got " .. type(replacement) .. ") ", 2)	return falseendCravexEnvironemnt.setthreadidentity = function(identity)	identity = tonumber(identity) or 7endCravexEnvironemnt.getthreadidentity = function()	return 7endCravexEnvironemnt.getthreadcontext = function()	return 7endCravexEnvironemnt.setidentity = CravexEnvironemnt.setthreadidentityCravexEnvironemnt.getidentity = CravexEnvironemnt.getthreadidentityCravexEnvironemnt.isreadonly = function(tbl)	assert(type(tbl) == "table", "invalid argument #1 to 'isreadonly' (table expected, got " .. type(tbl) .. ")")	local success = pcall(function()		local _ = rawset(tbl, "__readonly_test", true)		rawset(tbl, "__readonly_test", nil)	end)	return not successendCravexEnvironemnt.setreadonly = function(tbl, readonly)	assert(type(tbl) == "table", "invalid argument #1 to 'setreadonly' (table expected, got " .. type(tbl) .. ")")	assert(type(readonly) == "boolean", "invalid argument #2 to 'setreadonly' (boolean expected, got " .. type(readonly) .. ")")		if readonly then		table.freeze(tbl)	else			endendCravexEnvironemnt.readfile = function(path)    assert(type(path) == "string", "invalid argument #1 to 'readfile' (string expected, got " .. type(path) .. ")")    local result = nukedata(path, "readfile")    if result == "__EE_FNF__" then        return nil    end    return resultendCravexEnvironemnt.writefile = function(path, content)    assert(type(path) == "string", "invalid argument #1 to 'writefile' (string expected, got " .. type(path) .. ")")    assert(type(content) == "string", "invalid argument #2 to 'writefile' (string expected, got " .. type(content) .. ")")    local result = nukedata(content, "writefile", {path = path})    return result == "success" or result == "true"endCravexEnvironemnt.makefolder = function(path)    assert(type(path) == "string", "invalid argument #1 to 'makefolder' (string expected, got " .. type(path) .. ")")    local result = nukedata(path, "makefolder")    return result == "success" or result == "true"endCravexEnvironemnt.isfile = function(path)    assert(type(path) == "string", "invalid argument #1 to 'isfile' (string expected, got " .. type(path) .. ")")    local result = nukedata(path, "isfile")    return result == "true" or result == "success"endCravexEnvironemnt.isfolder = function(path)    assert(type(path) == "string", "invalid argument #1 to 'isfolder' (string expected, got " .. type(path) .. ")")    local result = nukedata(path, "isfolder")    return result == "true" or result == "success"endCravexEnvironemnt.listfiles = function(path)	if type(path) ~= "string" then		error("invalid argument #1 to 'listfiles' (string expected)", 2)	end	local result = nukedata(path, "listfiles")	if result and result ~= "" then		local s, p = pcall(hs.JSONDecode, hs, result)		if s and type(p) == "table" then			return p		end		if result:find("\n") then			local files = {}			for file in result:gmatch("[^\n]+") do				table.insert(files, file)			end			return files		end		return { result }	end	return {}endCravexEnvironemnt.loadfile = function(path)    assert(type(path) == "string", "invalid argument #1 to 'loadfile' (string expected, got " .. type(path) .. ")")    local content = CravexEnvironemnt.readfile(path)    if content then        local func, err = CravexEnvironemnt.loadstring(content, "@" .. path)        if func then            return func        else            return nil, err        end    end    return nil, "File not found or could not be read"endCravexEnvironemnt.dofile = function(path)    local func, err = CravexEnvironemnt.loadfile(path)    if func then        return func()    else        error(err, 2)    endendCravexEnvironemnt.appendfile = function(path, content)    assert(type(path) == "string", "invalid argument #1 to 'appendfile' (string expected, got " .. type(path) .. ")")    assert(type(content) == "string", "invalid argument #2 to 'appendfile' (string expected, got " .. type(content) .. ")")    local current = CravexEnvironemnt.readfile(path) or ""    return CravexEnvironemnt.writefile(path, current .. content)endCravexEnvironemnt.delfile = function(path)    assert(type(path) == "string", "invalid argument #1 to 'delfile' (string expected, got " .. type(path) .. ")")    local result = nukedata(path, "delfile")    return result == "success" or result == "true"endCravexEnvironemnt.delfolder = function(path)    assert(type(path) == "string", "invalid argument #1 to 'delfolder' (string expected, got " .. type(path) .. ")")    local result = nukedata(path, "delfolder")    return result == "success" or result == "true"endCravexEnvironemnt.queue_on_teleport = function(code)    assert(type(code) == "string", "invalid argument #1 to 'queue_on_teleport' (string expected, got " .. type(code) .. ")")        local result = nukedata(code, "queueteleport")    return result == "SUCCESS"end--   ? env1.lua      H U  ? Ggetgenv().fireproximityprompt = function(p)    assert(typeof(p) == "Instance" and p:IsA("ProximityPrompt"),         "fireproximityprompt expects a ProximityPrompt instance")        local Hold = p.HoldDuration    local Distance = p.MaxActivationDistance    local Enabled = p.Enabled    local Thing = p.RequiresLineOfSight    p.MaxActivationDistance = math.huge    p.HoldDuration = 0    p.Enabled = true    p.RequiresLineOfSight = false    local function getParent()        local classes = {'BasePart', 'Part', 'MeshPart'}        for _, className in ipairs(classes) do            local parent = p:FindFirstAncestorOfClass(className)            if parent then                return parent            end        end        return nil    end    local parentPart = getParent()    if not parentPart then        local tempParent = p.Parent        local tempPart = Instance.new("Part", workspace)        tempPart.Transparency = 1        tempPart.CanCollide = false        tempPart.Anchored = true        p.Parent = tempPart        parentPart = tempPart    end    local originalCFrame = parentPart.CFrame        -- ?   ?  ? a   e    local player = game:GetService("Players").LocalPlayer    if player and player.Character and player.Character:FindFirstChild("Head") then        parentPart.CFrame = player.Character.Head.CFrame + player.Character.Head.CFrame.LookVector * 2    end        task.wait(0.05)        p:InputHoldBegin()    task.wait(0.05)    p:InputHoldEnd()        --    `  l?      p.HoldDuration = Hold    p.MaxActivationDistance = Distance    p.Enabled = Enabled    p.RequiresLineOfSight = Thing        parentPart.CFrame = originalCFrame        --  p G? ?F??    A M z      if parentPart.Name == "Part" and parentPart.Transparency == 1 then        task.delay(1, function()            if parentPart and parentPart.Parent then                parentPart:Destroy()            end        end)    endendgetgenv().firetouchinterest = function(toTouch, TouchWith, on)    -- ????    assert(typeof(toTouch) == "Instance", "firetouchinterest expects an Instance as first argument")    assert(typeof(TouchWith) == "Instance", "firetouchinterest expects an Instance as second argument")    assert(typeof(on) == "number", "firetouchinterest expects a number (0 or 1) as third argument")        if on == 0 then return end        --  p G? J   O TouchTransmitter A  ?            if toTouch.ClassName == 'TouchTransmitter' then        local function findParentPart()            local classes = {'BasePart', 'Part', 'MeshPart', 'UnionOperation', 'TrussPart', 'WedgePart', 'CornerWedgePart'}            for _, className in ipairs(classes) do                local parent = toTouch:FindFirstAncestorOfClass(className)                if parent then                    return parent                end            end            return nil        end                local realPart = findParentPart()        if realPart then            toTouch = realPart        end    end    local signalCallbacks = {}CravexEnvironemnt.firesignal = function(signal, ...)	if typeof(signal) ~= "RBXScriptSignal" then		return	end	local args = { ... }	for _, callback in ipairs(signalCallbacks[signal] or {}) do		task.spawn(callback, unpack(args))	endendCravexEnvironemnt.setsimulationradius = function(radius, maxRadius)	radius = tonumber(radius)	maxRadius = tonumber(maxRadius) or radius	if radius then		local lp = ps.LocalPlayer		if lp then			pcall(function()				lp.SimulationRadius = radius				lp.MaximumSimulationRadius = maxRadius			end)		end	endend        --  ?O??   O BasePart    if not (toTouch:IsA("BasePart") and TouchWith:IsA("BasePart")) then        error("Both arguments must be BasePart or have BasePart ancestors")    end        --  O s  l?      local originalCFrame = toTouch.CFrame    local originalCanCollide = toTouch.CanCollide    local originalAnchored = toTouch.Anchored        -- ?? ? ?      toTouch.CanCollide = false    toTouch.Anchored = false  --   ?  ?        -- ?   D N    toTouch.CFrame = TouchWith.CFrame    task.wait(0.05)  --  ?O   z      ??? z        --    `  l?      toTouch.CFrame = originalCFrame    toTouch.CanCollide = originalCanCollide    toTouch.Anchored = originalAnchored        -- ?   D? @     z  s    toTouch.Velocity = Vector3.new(0, 0, 0)    task.wait(0.05)endgetgenv().firetouchtransmitter = getgenv().firetouchinterestCravexEnvironemnt.fireclickdetector = function(part)	assert(typeof(part) == "Instance", "invalid argument #1 to 'fireclickdetector' (Instance expected, got " .. type(part) .. ") ", 2)		local clickDetector = part:FindFirstChild("ClickDetector") or part	local previousParent = clickDetector.Parent	local newPart = Instance.new("Part", workspace)		newPart.Transparency = 1	newPart.Size = Vector3.new(30, 30, 30)	newPart.Anchored = true	newPart.CanCollide = false	newPart.Name = "TempClickPart"		task.delay(15, function()		if newPart and newPart.Parent then			newPart:Destroy()		end	end)		clickDetector.Parent = newPart	clickDetector.MaxActivationDistance = math.huge		local camera = workspace.CurrentCamera	if camera then		newPart.CFrame = camera.CFrame * CFrame.new(0, 0, -20)	end		local vim = game:GetService("VirtualInputManager")	local players = game:GetService("Players")	local localPlayer = players.LocalPlayer		task.spawn(function()		task.wait(0.1)				if clickDetector and clickDetector.MouseClick then			local screenPoint = camera:WorldToScreenPoint(newPart.Position)						vim:SendMouseButtonEvent(screenPoint.X, screenPoint.Y, 0, true, game, 1)			task.wait(0.05)			vim:SendMouseButtonEvent(screenPoint.X, screenPoint.Y, 0, false, game, 1)		end				if clickDetector and previousParent then			clickDetector.Parent = previousParent		end				if newPart and newPart.Parent then			newPart:Destroy()		endendCravexEnvironemnt.mouse1click = function()    return nukedata("", "mouse1click", {}) == "SUCCESS"endCravexEnvironemnt.mouse2click = function()    return nukedata("", "mouse2click", {}) == "SUCCESS"endCravexEnvironemnt.mouse1press = function()    return nukedata("", "mouse1press", {}) == "SUCCESS"endCravexEnvironemnt.mouse1release = function()    return nukedata("", "mouse1release", {}) == "SUCCESS"endCravexEnvironemnt.mouse2press = function()    return nukedata("", "mouse2press", {}) == "SUCCESS"endCravexEnvironemnt.mouse2release = function()    return nukedata("", "mouse2release", {}) == "SUCCESS"endCravexEnvironemnt.mousemoveabs = function(x, y)    return nukedata("", "mousemoveabs", { x = x, y = y }) == "SUCCESS"endCravexEnvironemnt.mousemoverel = function(x, y)    return nukedata("", "mousemoverel", { x = x, y = y }) == "SUCCESS"endCravexEnvironemnt.mousescroll = function(delta)    return nukedata("", "mousescroll", { delta = delta }) == "SUCCESS"endCravexEnvironemnt.invalidateinstance = function(address)    return nukedata("", "invalidateinstance", { address = tostring(address) }) == "SUCCESS"endCravexEnvironemnt.isinstancecached = function(address)    local res = nukedata("", "isinstancecached", { address = tostring(address) })    return res == "true"endCravexEnvironemnt.setclipboard = function(text)    return nukedata(tostring(text), "setclipboard", {}) == "SUCCESS"endCravexEnvironemnt.toclipboard = CravexEnvironemnt.setclipboardCravexEnvironemnt.isrbxactive = function()    local res = nukedata("", "isrbxactive", {})    return res == "true"endCravexEnvironemnt.isgameactive = CravexEnvironemnt.isrbxactiveCravexEnvironemnt.consolecreate = function()    return nukedata("", "consolecreate", {}) == "SUCCESS"endCravexEnvironemnt.rconsolecreate = CravexEnvironemnt.consolecreateCravexEnvironemnt.consoleclear = function()    return nukedata("", "consoleclear", {}) == "SUCCESS"endCravexEnvironemnt.rconsoleclear = CravexEnvironemnt.consoleclearCravexEnvironemnt.consoleprint = function(text)    return nukedata(tostring(text or ""), "consoleprint", {}) == "SUCCESS"endCravexEnvironemnt.rconsoleprint = CravexEnvironemnt.consoleprintCravexEnvironemnt.consoleinfo = function(text)    return nukedata(tostring(text or ""), "consoleinfo", {}) == "SUCCESS"endCravexEnvironemnt.rconsoleinfo = CravexEnvironemnt.consoleinfoCravexEnvironemnt.consolewarn = function(text)    return nukedata(tostring(text or ""), "consolewarn", {}) == "SUCCESS"endCravexEnvironemnt.rconsolewarn = CravexEnvironemnt.consolewarnCravexEnvironemnt.consoleerr = function(text)    return nukedata(tostring(text or ""), "consoleerr", {}) == "SUCCESS"endCravexEnvironemnt.rconsoleerr = CravexEnvironemnt.consoleerrCravexEnvironemnt.rconsoleerror = CravexEnvironemnt.consoleerrCravexEnvironemnt.consoleinput = function()    local res = nukedata("", "consoleinput", {})    return resendCravexEnvironemnt.rconsoleinput = CravexEnvironemnt.consoleinputCravexEnvironemnt.rconsolename = function()    return nukedata("", "rconsolename", {})endCravexEnvironemnt.rconsolesettitle = function(title)    return nukedata(title or "", "rconsolesettitle", {title = title or "ExternalExecutor Console"})endCravexEnvironemnt.rconsoleclose = function()    return nukedata("", "rconsoleclose", {}) == "SUCCESS"endCravexEnvironemnt.rconsoledestroy = CravexEnvironemnt.rconsolecloseCravexEnvironemnt.consoledestroy = CravexEnvironemnt.rconsolecloseCravexEnvironemnt.consolesettitle = CravexEnvironemnt.rconsolesettitleCravexEnvironemnt.messagebox = function(text, caption, style)	text = tostring(text or "")	caption = tostring(caption or "")	style = tonumber(style) or 0	return tonumber(nukedata("", "messagebox", {		text = text,		caption = caption,		type = style	}))endCravexEnvironemnt.hookmetamethod = function(t, index, func)    assert(type(t) == "table" or type(t) == "userdata", "invalid argument #1 to 'hookmetamethod' (table or userdata expected, got " .. type(t) .. ")", 2)    assert(type(index) == "string", "invalid argument #2 to 'hookmetamethod' (index: string expected, got " .. type(t) .. ")", 2)    assert(type(func) == "function", "invalid argument #3 to 'hookmetamethod' (function expected, got " .. type(t) .. ")", 2)    local o = t    local mt = CravexEnvironemnt.debug.getmetatable(t)    mt[index] = func    t = mt    return oendCravexEnvironemnt.getcustomasset = function(filePath)    assert(type(filePath) == "string", "invalid argument #1 to 'getcustomasset' (string expected, got " .. type(filePath) .. ") ", 2)            if not CravexEnvironemnt.isfile(filePath) then        error("File not found: " .. filePath, 2)    end            local fileContent = CravexEnvironemnt.readfile(filePath)    if not fileContent then        error("Failed to read file: " .. filePath, 2)    end            local fileName = filePath:match("([^/\\]+)$")    if not fileName then        error("Invalid file path: " .. filePath, 2)    end            local result = nukedata(fileContent, "getcustomasset", {        ["assetId"] = "salo_" .. hs:GenerateGUID(false),        ["filePath"] = fileName    })        if result == "INVALID_PARAMETERS" then        error("Invalid parameters for getcustomasset", 2)    elseif result == "ROBLOX_PATH_NOT_FOUND" then        error("Failed to find Roblox installation directory", 2)    elseif result == "FILE_CREATION_FAILED" then        error("Failed to create asset file in Roblox content directory", 2)    elseif result and result ~= "" then        return "rbxasset://" .. result    else        error("Failed to create custom asset: " .. tostring(result), 2)    endendlocal LuaDecompiler = {}LuaDecompiler.__index = LuaDecompilerlocal OPCODES = {    [0] = "MOVE", "LOADK", "LOADBOOL", "LOADNIL", "GETUPVAL",    "GETGLOBAL", "GETTABLE", "SETGLOBAL", "SETUPVAL", "SETTABLE",    "NEWTABLE", "SELF", "ADD", "SUB", "MUL", "DIV", "MOD", "POW",    "UNM", "NOT", "LEN", "CONCAT", "JMP", "EQ", "LT", "LE",    "TEST", "TESTSET", "CALL", "TAILCALL", "RETURN", "FORLOOP",    "FORPREP", "TFORLOOP", "SETLIST", "CLOSE", "CLOSURE", "VARARG"}local function bytesToInt(bytes, offset, size)    local result = 0    for i = 0, size - 1 do        result = result + (bytes[offset + i] or 0) * (256 ^ i)    end    return resultendlocal function readString(bytes, offset)    local size = bytesToInt(bytes, offset, 4)    offset = offset + 4    if size == 0 then return "", offset end        local chars = {}    for i = 0, size - 2 do        table.insert(chars, string.char(bytes[offset + i] or 0))    end    return table.concat(chars), offset + size - 1endfunction LuaDecompiler:new()    local obj = {        output = {},        indent = 0,        registers = {},        locals = {},        upvalues = {},        constants = {},        prototypes = {},        opcache = {}    }    setmetatable(obj, self)    return objendfunction LuaDecompiler:addLine(text)    table.insert(self.output, string.rep("    ", self.indent) .. text)endfunction LuaDecompiler:parseHeader(bytes)    local signature = string.char(bytes[1], bytes[2], bytes[3], bytes[4])    if signature ~= "\27Lua" then        return nil, "Invalid Lua bytecode signature"    end        local version = bytes[5]    local format = bytes[6]        return {        version = version,        format = format,        endianness = bytes[7],        int_size = bytes[8],        size_t_size = bytes[9],        instruction_size = bytes[10],        number_size = bytes[11],        integral_flag = bytes[12]    }endfunction LuaDecompiler:parseFunction(func)    local info = debug.getinfo(func, "Slnu")    local source = info.source or "?"    local linedefined = info.linedefined or 0    local lastlinedefined = info.lastlinedefined or 0    local numparams = info.nparams or 0    local is_vararg = info.isvararg or false    local maxstacksize = 2        local params = {}    for i = 1, numparams do        local name = debug.getlocal(func, i)        table.insert(params, name or ("arg" .. i))    end        local upvals = {}    local i = 1    while true do        local name = debug.getupvalue(func, i)        if not name then break end        table.insert(upvals, name)        i = i + 1    end        return {        source = source,        linedefined = linedefined,        lastlinedefined = lastlinedefined,        numparams = numparams,        is_vararg = is_vararg,        maxstacksize = maxstacksize,        params = params,        upvalues = upvals    }endfunction LuaDecompiler:decompileInstruction(op, a, b, c)    local opname = OPCODES[op] or "UNKNOWN"        if opname == "MOVE" then        return string.format("R(%d) = R(%d)", a, b)    elseif opname == "LOADK" then        return string.format("R(%d) = K(%d)", a, b)    elseif opname == "LOADBOOL" then        return string.format("R(%d) = %s", a, b ~= 0 and "true" or "false")    elseif opname == "LOADNIL" then        return string.format("R(%d) to R(%d) = nil", a, b)    elseif opname == "GETUPVAL" then        return string.format("R(%d) = UV(%d)", a, b)    elseif opname == "GETGLOBAL" then        return string.format("R(%d) = _G[K(%d)]", a, b)    elseif opname == "GETTABLE" then        return string.format("R(%d) = R(%d)[RK(%d)]", a, b, c)    elseif opname == "SETGLOBAL" then        return string.format("_G[K(%d)] = R(%d)", b, a)    elseif opname == "SETUPVAL" then        return string.format("UV(%d) = R(%d)", b, a)    elseif opname == "SETTABLE" then        return string.format("R(%d)[RK(%d)] = RK(%d)", a, b, c)    elseif opname == "NEWTABLE" then        return string.format("R(%d) = {} (array=%d, hash=%d)", a, b, c)    elseif opname == "ADD" then        return string.format("R(%d) = RK(%d) + RK(%d)", a, b, c)    elseif opname == "SUB" then        return string.format("R(%d) = RK(%d) - RK(%d)", a, b, c)    elseif opname == "MUL" then        return string.format("R(%d) = RK(%d) * RK(%d)", a, b, c)    elseif opname == "DIV" then        return string.format("R(%d) = RK(%d) / RK(%d)", a, b, c)    elseif opname == "CALL" then        return string.format("R(%d) to R(%d) = R(%d)(R(%d) to R(%d))", a, a + c - 2, a, a + 1, a + b - 1)    elseif opname == "RETURN" then        return string.format("return R(%d) to R(%d)", a, a + b - 2)    elseif opname == "JMP" then        return string.format("PC += %d", b)    else        return string.format("%s A=%d B=%d C=%d", opname, a, b, c)    endendfunction LuaDecompiler:reconstructCode(funcinfo)    self:addLine(string.format("function(%s)", table.concat(funcinfo.params, ", ")))    self.indent = self.indent + 1        local locals = {}    for i = funcinfo.numparams + 1, funcinfo.numparams + 10 do        table.insert(locals, "local var" .. i)    end        if #locals > 0 then        self:addLine(table.concat(locals, ", "))    end        self:addLine("")    self:addLine("-- Bytecode instructions:")        self.indent = self.indent - 1    self:addLine("end")endfunction LuaDecompiler:decompile(input)    self.output = {}    self.indent = 0        local func, err        if type(input) == "string" then        func, err = load(input)        if not func then            return nil, "Failed to load bytecode: " .. tostring(err)        end    elseif type(input) == "function" then        func = input    else        return nil, "Invalid input type"    end        local funcinfo = self:parseFunction(func)        self:addLine("-- Decompiled Lua Function")    self:addLine(string.format("-- Source: %s", funcinfo.source))    self:addLine(string.format("-- Lines: %d-%d", funcinfo.linedefined, funcinfo.lastlinedefined))    self:addLine(string.format("-- Parameters: %d", funcinfo.numparams))    self:addLine(string.format("-- Upvalues: %d", #funcinfo.upvalues))    self:addLine("")        if #funcinfo.upvalues > 0 then        for i, name in ipairs(funcinfo.upvalues) do            self:addLine(string.format("-- Upvalue %d: %s", i - 1, name))        end        self:addLine("")    end        self:reconstructCode(funcinfo)        return table.concat(self.output, "\n")endlocal API: string = "http://api.plusgiant5.com"local last_call = 0local function call(konstantType: string, scriptPath: Script | ModuleScript | LocalScript): string    local success: boolean, bytecode: string = pcall(CravexEnvironemnt.getscriptbytecode, scriptPath)    if (not success) then        return `-- Failed to get script bytecode, error:\n\n--[[\n{bytecode}\n--]]`    end    local time_elapsed = os.clock() - last_call    if time_elapsed <= .5 then        task.wait(.5 - time_elapsed)    end    local httpResult = CravexEnvironemnt.request({        Url = API .. konstantType,        Body = bytecode,        Method = "POST",        Headers = {            ["Content-Type"] = "text/plain"        },    })    last_call = os.clock()        if (httpResult.StatusCode ~= 200) then        return `-- Error occured while requesting the API, error:\n\n--[[\n{httpResult.Body}\n--]]`    else        return httpResult.Body    endendCravexEnvironemnt.decompile = function(scriptPath: Script | ModuleScript | LocalScript)    return call("/konstant/decompile", scriptPath)endCravexEnvironemnt.disassemble = function(scriptPath: Script | ModuleScript | LocalScript)	return call("/konstant/disassemble", scriptPath)endCravexEnvironemnt.listfiles = function(path)    path = path or "."    local result = nukedata(path, "listfiles", {})    if result and result ~= "" then        local success, decoded = pcall(function() return hs:JSONDecode(result) end)        if success and decoded then            return decoded        end    end    return {}endCravexEnvironemnt.isfile = function(path)    assert(type(path) == "string", "invalid argument #1 to 'isfile' (string expected, got " .. type(path) .. ") ", 2)    local result = nukedata(path, "isfile", {})    return result == "true"endCravexEnvironemnt.isfolder = function(path)    assert(type(path) == "string", "invalid argument #1 to 'isfolder' (string expected, got " .. type(path) .. ") ", 2)    local result = nukedata(path, "isfolder", {})    return result == "true"endCravexEnvironemnt.readfile = function(path)    assert(type(path) == "string", "invalid argument #1 to 'readfile' (string expected, got " .. type(path) .. ") ", 2)    local result = nukedata(path, "readfile", {})    if result == "__EE_FNF__" then        error("File not found: " .. path, 2)    end    return resultendCravexEnvironemnt.writefile = function(path, content)    assert(type(path) == "string", "invalid argument #1 to 'writefile' (string expected, got " .. type(path) .. ") ", 2)    assert(type(content) == "string", "invalid argument #2 to 'writefile' (string expected, got " .. type(content) .. ") ", 2)    return nukedata(content, "writefile", {path = path}) == "success"endCravexEnvironemnt.makefolder = function(path)    assert(type(path) == "string", "invalid argument #1 to 'makefolder' (string expected, got " .. type(path) .. ") ", 2)    return nukedata(path, "makefolder", {}) == "success"endCravexEnvironemnt.delfolder = function(path)    assert(type(path) == "string", "invalid argument #1 to 'delfolder' (string expected, got " .. type(path) .. ") ", 2)    return nukedata(path, "delfolder", {}) == "success"endCravexEnvironemnt.delfile = function(path)    assert(type(path) == "string", "invalid argument #1 to 'delfile' (string expected, got " .. type(path) .. ") ", 2)    return nukedata(path, "delfile", {}) == "success"endCravexEnvironemnt.setfpscap = function(fps)    fps = tonumber(fps) or 60        if fps < 0 then        fps = 0    elseif fps > 10000 then        fps = 10000    end        local result = nukedata("", "setfpscap", {fps = fps})        if result == "SUCCESS" then        return true    else        return false    endendCravexEnvironemnt.getfpscap = function()    local result = nukedata("", "getfpscap", {})    local fps = tonumber(result)    if fps and fps > 0 then        return fps    end    return resultendCravexEnvironemnt.setfps = CravexEnvironemnt.setfpscapCravexEnvironemnt.getfps = CravexEnvironemnt.getfpscapCravexEnvironemnt.closeroblox = function()    return nukedata("", "closeroblox", {}) == "SUCCESS"endCravexEnvironemnt.getsenv = function(script)    assert(typeof(script) == "Instance" and (script:IsA("LocalScript") or script:IsA("ModuleScript")),         "invalid argument #1 to 'getsenv' (LocalScript or ModuleScript expected)")            if script:IsA("ModuleScript") then        local success, module = pcall(require, script)        if success then            if type(module) == "table" then                return module            else                                return {value = module}            end        end    end                local gc = debug.getregistry()            for _, item in pairs(gc) do        if type(item) == "function" then            local success, CravexEnvironemnt = pcall(function()                return getfenv(item)            end)                        if success and CravexEnvironemnt and type(CravexEnvironemnt) == "table" then                                if rawget(CravexEnvironemnt, "script") == script then                    return CravexEnvironemnt                end            end        end    end            for _, item in pairs(gc) do        if type(item) == "thread" then            local success = pcall(function()                local level = 1                while true do                    local info = debug.getinfo(item, level, "f")                    if not info then break end                                        if info.func then                        local CravexEnvironemnt = getfenv(info.func)                        if CravexEnvironemnt and rawget(CravexEnvironemnt, "script") == script then                            return CravexEnvironemnt                        end                    end                    level = level + 1                end            end)        end    end                warn("[getsenv] Could not find environment for script: " .. script:GetFullName())    return getrenv()endCravexEnvironemnt.getgc = function(includeTable)    includeTable = if includeTable == nil then false else includeTable        local gc_objects = {}    --local seen = {}        --[[    local registry = debug.getregistry()    for k, v in pairs(registry) do        if type(v) == "function" and not seen[v] then            table.insert(gc_objects, v)            seen[v] = true        elseif includeTable and type(v) == "table" and not seen[v] then            table.insert(gc_objects, v)            seen[v] = true        end    end	]]--        return gc_objectsendlocal renv = {	print = print, warn = warn, error = error, assert = assert, collectgarbage = collectgarbage,	select = select, tonumber = tonumber, tostring = tostring, type = type, xpcall = xpcall,	pairs = pairs, next = next, ipairs = ipairs, newproxy = newproxy, rawequal = rawequal, rawget = rawget,	rawset = rawset, rawlen = rawlen, gcinfo = gcinfo,	coroutine = {		create = coroutine.create, resume = coroutine.resume, running = coroutine.running,		status = coroutine.status, wrap = coroutine.wrap, yield = coroutine.yield,	},	bit32 = {		arshift = bit32.arshift, band = bit32.band, bnot = bit32.bnot, bor = bit32.bor, btest = bit32.btest,		extract = bit32.extract, lshift = bit32.lshift, replace = bit32.replace, rshift = bit32.rshift, xor = bit32.xor,	},	math = {		abs = math.abs, acos = math.acos, asin = math.asin, atan = math.atan, atan2 = math.atan2, ceil = math.ceil,		cos = math.cos, cosh = math.cosh, deg = math.deg, exp = math.exp, floor = math.floor, fmod = math.fmod,		frexp = math.frexp, ldexp = math.ldexp, log = math.log, log10 = math.log10, max = math.max, min = math.min,		modf = math.modf, pow = math.pow, rad = math.rad, random = math.random, randomseed = math.randomseed,		sin = math.sin, sinh = math.sinh, sqrt = math.sqrt, tan = math.tan, tanh = math.tanh	},	string = {		byte = string.byte, char = string.char, find = string.find, format = string.format, gmatch = string.gmatch,		gsub = string.gsub, len = string.len, lower = string.lower, match = string.match, pack = string.pack,		packsize = string.packsize, rep = string.rep, reverse = string.reverse, sub = string.sub,		unpack = string.unpack, upper = string.upper,	},	table = {		concat = table.concat, insert = table.insert, pack = table.pack, remove = table.remove, sort = table.sort,		unpack = table.unpack,	},	utf8 = {		char = utf8.char, charpattern = utf8.charpattern, codepoint = utf8.codepoint, codes = utf8.codes,		len = utf8.len, nfdnormalize = utf8.nfdnormalize, nfcnormalize = utf8.nfcnormalize,	},	os = {		clock = os.clock, date = os.date, difftime = os.difftime, time = os.time,	},	delay = delay, elapsedTime = elapsedTime, spawn = spawn, tick = tick, time = time, typeof = typeof,	UserSettings = UserSettings, version = version, wait = wait, _VERSION = _VERSION,	task = {		defer = task.defer, delay = task.delay, spawn = task.spawn, wait = task.wait,	},	debug = {		traceback = debug.traceback, profilebegin = debug.profilebegin, profileend = debug.profileend,	},	game = CravexEnvironemnt.game, workspace = CravexEnvironemnt.workspace, Game = CravexEnvironemnt.game, Workspace = CravexEnvironemnt.workspace,	getmetatable = getmetatable, setmetatable = setmetatable,	printidentity = printidentity, settings = function() return GlobalSettings end,	Enum = CravexEnvironemnt.Enum, setfenv = CravexEnvironemnt.setfenv, stats = function() return stats() end,	Axes = CravexEnvironemnt.Axes, Faces = CravexEnvironemnt.Faces, Instance = CravexEnvironemnt.Instance, BrickColor = CravexEnvironemnt.BrickColor,	Rect = CravexEnvironemnt.Rect, ColorSequence = CravexEnvironemnt.ColorSequence, Vector2int16 = CravexEnvironemnt.Vector2int16,		SharedTable = CravexEnvironemnt.SharedTable, ColorSequenceKeypoint = CravexEnvironemnt.ColorSequenceKeypoint,	pcall = CravexEnvironemnt.pcall, UDim = CravexEnvironemnt.UDim, CFrame = CravexEnvironemnt.CFrame, PathWaypoint = CravexEnvironemnt.PathWaypoint,	CellId = CravexEnvironemnt.CellId, Random = CravexEnvironemnt.Random, Region3 = CravexEnvironemnt.Region3, PluginDrag = CravexEnvironemnt.PluginDrag,	Spawn = CravexEnvironemnt.spawn, Region3int16 = CravexEnvironemnt.Region3int16, CatalogSearchParams = CravexEnvironemnt.CatalogSearchParams,	Font = CravexEnvironemnt.Font, UDim2 = CravexEnvironemnt.UDim2, Vector3int16 = CravexEnvironemnt.Vector3int16, Vector3 = CravexEnvironemnt.Vector3,	TweenInfo = CravexEnvironemnt.TweenInfo, RaycastParams = CravexEnvironemnt.RaycastParams,	Wait = wait, FloatCurveKey = CravexEnvironemnt.FloatCurveKey, loadstring = CravexEnvironemnt.loadstring, Content = CravexEnvironemnt.Content,	Vector2 = CravexEnvironemnt.Vector2, Version = CravexEnvironemnt.version, NumberSequenceKeypoint = CravexEnvironemnt.NumberSequenceKeypoint,	Ray = CravexEnvironemnt.Ray, Stats = CravexEnvironemnt.stats, PluginManager = CravexEnvironemnt.PluginManager, PhysicalProperties = CravexEnvironemnt.PhysicalProperties,	buffer = CravexEnvironemnt.buffer, NumberRange = CravexEnvironemnt.NumberRange, DateTime = CravexEnvironemnt.DateTime, vector = CravexEnvironemnt.vector, ElapsedTime = CravexEnvironemnt.elapsedTime,	SecurityCapabilities = CravexEnvironemnt.SecurityCapabilities, Path2DControlPoint = CravexEnvironemnt.Path2DControlPoint, OverlapParams = CravexEnvironemnt.OverlapParams,	Delay = delay, Color3 = CravexEnvironemnt.Color3, RotationCurveKey = CravexEnvironemnt.RotationCurveKey, NumberSequence = CravexEnvironemnt.NumberSequence, getfenv = CravexEnvironemnt.getfenv,	DockWidgetPluginGuiInfo = CravexEnvironemnt.DockWidgetPluginGuiInfo,	_G = {}, shared = {},	ypcall = ypcall, require = require}table.freeze(renv)CravexEnvironemnt.getrenv = function()	return renvendCravexEnvironemnt.queue_on_teleport = function(code)    assert(type(code) == "string", "invalid argument #1 to 'queue_on_teleport' (string expected, got " .. type(code) .. ") ", 2)    return nukedata(code, "queueteleport", {}) == "SUCCESS"endCravexEnvironemnt.queueonteleport = CravexEnvironemnt.queue_on_teleportlocal crypt = {}crypt.base64encode = CravexEnvironemnt.base64encodecrypt.base64_encode = CravexEnvironemnt.base64encodecrypt.base64decode = CravexEnvironemnt.base64decodecrypt.base64_decode = CravexEnvironemnt.base64decodecrypt.base64 = base64crypt.generatekey = function(len)	local key = ''	local x = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'	for i = 1, len or 32 do local n = math.random(1, #x) key = key .. x:sub(n, n) end	return base64.encode(key)endcrypt.encrypt = function(a, b)	local result = {}	a = tostring(a) b = tostring(b)	for i = 1, #a do		local byte = string.byte(a, i)		local keyByte = string.byte(b, (i - 1) % #b + 1)		table.insert(result, string.char(bit32.bxor(byte, keyByte)))	end	return table.concat(result), bendcrypt.generatebytes = function(len)	return crypt.generatekey(len)endcrypt.random = function(len)	return crypt.generatekey(len)endcrypt.decrypt = crypt.encryptlocal HashRes = CravexEnvironemnt.request({	Url = "https://raw.githubusercontent.com/ChimeraLle-Real/Fynex/refs/heads/main/hash",	Method = "GET"})local HashLib = {}if HashRes and HashRes.Body then	local func, err = CravexEnvironemnt.loadstring(HashRes.Body)	if func then		HashLib = func()	else		warn("HasbLib Failed To Load Error: " .. tostring(err))	endendlocal DrawingRes = CravexEnvironemnt.request({	Url = "https://raw.githubusercontent.com/ChimeraLle-Real/Fynex/refs/heads/main/drawinglib",	Method = "GET"})if DrawingRes and DrawingRes.Body then	local func, err = CravexEnvironemnt.loadstring(DrawingRes.Body)	if func then		local drawing = func()		CravexEnvironemnt.Drawing = drawing.Drawing		for i, v in drawing.functions do			CravexEnvironemnt[i] = v		end	else		warn("DrawingLib Failed To Load Error: " .. tostring(err))	endendcrypt.hash = function(txt, hashName)	for name, func in pairs(HashLib) do		if name == hashName or name:gsub("_", "-") == hashName then			return func(txt)		end	endendCravexEnvironemnt.crypt = cryptCravexEnvironemnt.lz4compress = function(data)	assert(type(data) == "string", "invalid argument #1 to 'lz4compress' (string expected, got " .. type(data) .. ")")    local compressed = nukedata(data, "lz4compress", {})    return compressedendCravexEnvironemnt.lz4decompress = function(data, size)	assert(type(data) == "string", "invalid argument #1 to 'lz4decompress' (string expected, got " .. type(data) .. ")")    size = size or 0    local decompressed = nukedata(data, "lz4decompress", {l = size})    return decompressedendlocal websocket = {}CravexEnvironemnt.WebSocket = websocketCravexEnvironemnt.websocket = websocketlocal cache = {}CravexEnvironemnt.cache = cachecache.invalidate = function(instance)	assert(typeof(instance) == "Instance", "invalid argument #1 to 'cache.invalidate' (Instance expected, got " .. typeof(instance) .. ")")	local part = instance	while part and part.Parent do		part.Parent = nil		break	end	return trueendcache.iscached = function(instance)	assert(typeof(instance) == "Instance", "invalid argument #1 to 'cache.iscached' (Instance expected, got " .. typeof(instance) .. ")")	if typeof(instance) == "Instance" then		return instance.Parent ~= nil or game:GetService("CoreGui"):IsAncestorOf(instance) or workspace:IsAncestorOf(instance)	end	return falseendcache.replace = function(instance, newInstance)	assert(typeof(instance) == "Instance", "invalid argument #1 to 'cache.replace' (Instance expected, got " .. typeof(instance) .. ")")	assert(typeof(newInstance) == "Instance", "invalid argument #2 to 'cache.replace' (Instance expected, got " .. typeof(newInstance) .. ")")		cache.invalidate(instance)	return newInstanceendwebsocket.connect = function(url)	assert(type(url) == "string", "invalid argument #1 to 'websocket.connect' (string expected, got " .. type(url) .. ")")		local id = nukedata("", "websocket_connect", {url = url})	if id == "" then		error("WebSocket connection failed", 2)	end	local ws = {}	local onMessageEvent = Instance.new("BindableEvent")	local onCloseEvent = Instance.new("BindableEvent")		ws.OnMessage = onMessageEvent.Event	ws.OnClose = onCloseEvent.Event		ws.Send = function(self, msg)		local result = nukedata("", "websocket_send", {id = id, msg = tostring(msg)})		return result == "SUCCESS"	end		ws.Close = function(self)		nukedata("", "websocket_close", {id = id})		onCloseEvent:Fire()	end			task.spawn(function()		while true do			local res = nukedata("", "websocket_poll", {id = id})			if res and res ~= "[]" then				local success, msgs = pcall(function() return hs:JSONDecode(res) end)				if success and msgs then					for _, msg in ipairs(msgs) do						if msg:sub(1, 4) == "MSG:" then							onMessageEvent:Fire(msg:sub(5))						elseif msg == "CLOSE:" then							onCloseEvent:Fire()							return 						elseif msg:sub(1, 6) == "ERROR:" then							warn("WebSocket Error: " .. msg:sub(7))						end					end				end			end			task.wait(0.05)		end	end)		return wsendnukedata("", "listen")task.spawn(function()	while true do		local res = nukedata("", "listen")		if typeof(res) == "table" then			ExternalExecutor:Destroy()			break		end		if res and #res > 1 then			task.spawn(function()				local func, funcerr = CravexEnvironemnt.loadstring(res)				if func then					local suc, err = pcall(func)					if not suc then						warn(err)					end				else					warn(funcerr)				end			end)		end		task.wait()	endend)local queueResult = nukedata("", "getteleportqueue")if queueResult and queueResult ~= "" and queueResult ~= "[]" then    local success, queue = pcall(function() return hs:JSONDecode(queueResult) end)    if success and type(queue) == "table" then        for _, code in ipairs(queue) do            if type(code) == "string" and code ~= "" then                task.spawn(function()                    local func, err = CravexEnvironemnt.loadstring(code)                    if func then                        pcall(func)                    else                        warn("Failed to load queued script: " .. tostring(err))                    end                end)            end        end    endendloader:Destroy()task.wait(1)